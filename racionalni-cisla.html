<!doctype html>
<html lang="cs">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Racion√°ln√≠ ƒç√≠sla ‚Äì kola po 6 p≈ô√≠kladech</title>
<meta name="theme-color" content="#0b1323" />
<style>
  :root{
    --bg:#0b1323; --panel:#0f1729; --text:#e6eef8; --muted:#9fb0c7; --accent:#60a5fa;
    --ok:#22c55e; --wrong:#ef4444; --card:#101826;
  }
  *{box-sizing:border-box}
  html,body{
    height:100%;margin:0;
    background:linear-gradient(180deg,var(--bg),#0d1528);
    color:var(--text);
    font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif
  }
  .app{max-width:min(800px,96vw);margin:24px auto;padding:16px}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:16px;flex-wrap:wrap}
  .tag{
    padding:4px 10px;
    border-radius:999px;
    border:1px solid #233152;
    color:var(--muted);
    font-size:13px;
  }
  .btn{
    appearance:none;border:1px solid #25324f;background:#15203a;
    color:var(--text);padding:8px 14px;border-radius:12px;cursor:pointer;
    font-size:14px;
  }
  .btn.primary{border-color:#245bb5;background:#1b3b70}
  .btn:disabled{opacity:.5;cursor:default}
  .panel{
    background:var(--panel);
    border-radius:18px;
    border:1px solid #1b2946;
    padding:16px;
  }
  .qtext{
    font-size:24px;
    line-height:1.3;
    margin-bottom:12px;
    min-height:2em;
  }
  .status{
    font-size:14px;
    color:var(--muted);
    min-height:1.5em;
  }
  .status.ok{color:var(--ok)}
  .status.bad{color:var(--wrong)}
  .answer-area{
    margin:10px 0 4px;
  }

  .whole-input{
    padding:8px 10px;
    border-radius:10px;
    border:1px solid #243356;
    background:#0f1729;
    color:var(--text);
    font-size:18px;
    width:160px;
  }
  .whole-input:focus{outline:none;border-color:var(--accent)}

  .frac-wrapper{
    display:none;
    align-items:center;
    justify-content:flex-start;
    gap:6px;
  }
  .frac-box{
    display:inline-flex;
    flex-direction:column;
    align-items:stretch;
    justify-content:center;
  }
  .frac-input{
    width:120px;
    padding:4px 8px;
    border-radius:6px;
    border:1px solid #243356;
    background:#0f1729;
    color:var(--text);
    font-size:16px;
    text-align:center;
  }
  .frac-input:focus{outline:none;border-color:var(--accent)}
  .frac-bar{
    height:1px;
    background:#e5e7eb;
    margin:3px 0;
  }

  .kbd{
    margin-top:10px;
    display:grid;
    grid-template-columns:repeat(4, minmax(0,1fr));
    gap:6px;
  }
  .kbd button{
    padding:10px 0;
    font-size:18px;
    border-radius:10px;
    border:1px solid #243356;
    background:#101826;
    color:var(--text);
    cursor:pointer;
  }
  .kbd button:hover{background:#18233e}
  .kbd button.k-wide{
    grid-column:span 2;
  }

  .bottom-bar{
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-top:12px;
    gap:10px;
    flex-wrap:wrap;
  }

  .icons-wrap{
    position:fixed;
    top:8px;
    right:10px;
    display:flex;
    flex-direction:column;
    gap:4px;
    z-index:10;
    font-size:18px;
  }
  .icons-line{
    display:flex;
    gap:4px;
    align-items:center;
  }
</style>

<!-- MathJax -->
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div class="icons-wrap">
  <div class="icons-line">
    üëµ <span id="grannyCount">0</span>
  </div>
  <div class="icons-line">
    üòà <span id="devilCount">0</span>
  </div>
</div>

<div class="app">
  <header>
    <div class="tag">Kolo: <span id="roundNo">1</span></div>
    <div class="tag">P≈ô√≠klad v kole: <span id="qIndex">1</span> / 6</div>
    <div class="tag">Spr√°vn√Ωch celkem: <span id="qCorrect">0</span></div>
    <div class="tag">≈†patn√Ωch celkem: <span id="qWrong">0</span></div>
    <div style="flex:1"></div>
    <button class="btn" id="btnResetAll">Reset v≈°e</button>
  </header>

  <section class="panel">
    <div class="qtext" id="qText"></div>

    <div class="answer-area">
      <input id="answerWhole" class="whole-input" autocomplete="off" inputmode="decimal" />
      <div id="fracWrapper" class="frac-wrapper">
        <span>=</span>
        <div class="frac-box">
          <input id="answerNum" class="frac-input" autocomplete="off" inputmode="numeric" />
          <div class="frac-bar"></div>
          <input id="answerDen" class="frac-input" autocomplete="off" inputmode="numeric" />
        </div>
      </div>
    </div>

    <div class="kbd" id="kbd">
      <button data-key="7">7</button>
      <button data-key="8">8</button>
      <button data-key="9">9</button>
      <button data-key="back">‚Üê</button>

      <button data-key="4">4</button>
      <button data-key="5">5</button>
      <button data-key="6">6</button>
      <button data-key="clear">C</button>

      <button data-key="1">1</button>
      <button data-key="2">2</button>
      <button data-key="3">3</button>
      <button data-key="neg">‚àí</button>

      <button data-key="0">0</button>
      <button data-key=",">,</button>
      <button class="k-wide" data-key="frac">zlomkov√° ƒç√°ra</button>
    </div>

    <div class="bottom-bar">
      <div>
        <button class="btn primary" id="btnCheck">Ovƒõ≈ôit v√Ωsledek</button>
        <button class="btn" id="btnNext" disabled>Dal≈°√≠ p≈ô√≠klad</button>
        <button class="btn" id="btnNextRound" disabled>Dal≈°√≠ kolo</button>
      </div>
      <div id="status" class="status"></div>
    </div>
  </section>
</div>

<script>
/* ---------- pomocn√© funkce pro ƒç√≠sla / zlomky ---------- */
function randInt(min, max){
  return Math.floor(Math.random()*(max-min+1))+min;
}
function choice(arr){
  return arr[Math.floor(Math.random()*arr.length)];
}
function gcd(a,b){
  a=Math.abs(a); b=Math.abs(b);
  while(b){ let t=a%b; a=b; b=t; }
  return a||1;
}
function makeFrac(n,d){
  if(d === 0) return {n:1,d:0};
  if(d < 0){ n=-n; d=-d; }
  const g = gcd(n,d);
  n = n/g; d = d/g;
  return {n,d};
}
function addFrac(a,b){
  return makeFrac(a.n*b.d + b.n*a.d, a.d*b.d);
}
function subFrac(a,b){
  return makeFrac(a.n*b.d - b.n*a.d, a.d*b.d);
}
function mulFrac(a,b){
  return makeFrac(a.n*b.n, a.d*b.d);
}
function divFrac(a,b){
  return makeFrac(a.n*b.d, a.d*b.n);
}
function fracValue(fr){ return fr.n/fr.d; }

/* "hezk√Ω" zlomek jako v√Ωsledek: |n|<=99, d<=99, d | 1000 */
function isNiceResult(fr){
  if(fr.d === 0) return false;
  const n = Math.abs(fr.n), d = Math.abs(fr.d);
  if(n > 99 || d > 99) return false;
  if(1000 % d !== 0) return false;
  return true;
}

/* form√°t desetinn√©ho ƒç√≠sla s ƒç√°rkou (max 3 desetinn√° m√≠sta) */
function fmtDec(x){
  let s = x.toFixed(3);
  s = s.replace('.', ',');
  if(s.includes(',')){
    s = s.replace(/0+$/,'').replace(/,$/,'');
  }
  return s;
}

/* TeX pro zlomek:
   - kdy≈æ d=1, vrac√≠ jen cel√© ƒç√≠slo
   - jinak vrac√≠ \frac{n}{d} se spr√°vn√Ωm znam√©nkem */
function texFrac(fr){
  const n = fr.n, d = fr.d;
  if(d === 1) return String(n);
  if(n < 0) return '-\\frac{' + Math.abs(n) + '}{' + d + '}';
  return '\\frac{' + n + '}{' + d + '}';
}
function texFracParen(fr){
  return '\\left(' + texFrac(fr) + '\\right)';
}
function texDec(fr){
  return fmtDec(fracValue(fr));
}

/* n√°hodn√Ω desetinn√Ω zlomek ‚Äì d=10 nebo 100 */
function randDecFrac(min, max, denChoices){
  while(true){
    const d = choice(denChoices || [10,100]);
    const nMin = Math.ceil(min*d);
    const nMax = Math.floor(max*d);
    if(nMin > nMax) continue;
    const n = randInt(nMin, nMax);
    const fr = makeFrac(n,d);
    // nechceme n/d = 1, 2/2 apod.
    if(Math.abs(fr.n) === fr.d) continue;
    return fr;
  }
}

/* n√°hodn√Ω "hezk√Ω" zlomek ‚Äì q jen z mocnin 2 a 5 */
function randNiceFrac(numMax, denChoices){
  while(true){
    const d = choice(denChoices || [2,4,5,8,10,20]);
    let n = randInt(-numMax, numMax);
    if(n === 0) continue;
    const fr = makeFrac(n,d);
    if(Math.abs(fr.n) === fr.d) continue; // nechceme 1/1, 2/2,...
    if(Math.abs(fr.n) <= numMax && Math.abs(fr.d) <= 99) return fr;
  }
}

/* ---------- gener√°tory 6 typ≈Ø p≈ô√≠klad≈Ø (pevn√° struktura A) ---------- */

/* TYPE 1: [a : f1 + b : c ‚àí d] ¬∑ e */
function genType1(){
  while(true){
    const a = randDecFrac(0.2, 0.8, [10,100]);
    const b = randDecFrac(-0.7, -0.2, [10,100]);
    const c = randDecFrac(-1.5, -0.8, [10,100]);
    const dInt = randInt(4,10);
    const d = makeFrac(dInt,1);

    const f1 = randNiceFrac(3,[2,4,5]);
    const e  = randNiceFrac(4,[5,10,20]);

    const term1 = divFrac(a,f1);
    const term2 = divFrac(b,c);
    let inner = addFrac(term1,term2);
    inner = subFrac(inner,d);
    const res = mulFrac(inner,e);

    if(!isNiceResult(res)) continue;

    const latex =
      '\\big[ ' + texDec(a) + ' : ' + texFrac(f1) +
      ' + \\left(' + texDec(b) + '\\right) : \\left(' + texDec(c) + '\\right) - ' +
      dInt + ' \\big] \\cdot ' + texFrac(e);

    return { latex, frac: res };
  }
}

/* TYPE 2: (A‚àíB) ¬∑ (C‚àíD) + E : (m/n) */
function genType2(){
  while(true){
    const A = randDecFrac(3.0,7.0,[10]);
    const B = randDecFrac(1.0,3.0,[10]);
    const C = randDecFrac(7.0,10.0,[10]);
    const D = randDecFrac(9.0,12.0,[10]);

    const E = randDecFrac(-2.0,-1.0,[10,100]);
    const fracMN = randNiceFrac(5,[5,10,20]);

    const part1 = mulFrac(subFrac(A,B), subFrac(C,D));
    const part2 = divFrac(E, fracMN);
    const res = addFrac(part1, part2);

    if(!isNiceResult(res)) continue;

    const latex =
      '\\left(' + texDec(A) + ' - ' + texDec(B) + '\\right) \\cdot ' +
      '\\left(' + texDec(C) + ' - ' + texDec(D) + '\\right) + ' +
      '\\left(' + texDec(E) + '\\right) : ' + texFrac(fracMN);

    return { latex, frac: res };
  }
}

/* TYPE 3: (‚àíp/q) ¬∑ r/s + (dec) ¬∑ t/u */
function genType3(){
  while(true){
    const pOverQ = randNiceFrac(8,[2,4,5,8,10]);
    const negPQ = makeFrac(-pOverQ.n, pOverQ.d);
    const rOverS = randNiceFrac(6,[2,4,5,8,10]);
    const tOverU = randNiceFrac(6,[2,4,5,8,10]);
    const dec = randDecFrac(-1.2,-0.4,[10,100]);

    const part1 = mulFrac(negPQ, rOverS);
    const part2 = mulFrac(dec, tOverU);
    const res = addFrac(part1, part2);

    if(!isNiceResult(res)) continue;

    const latex =
      texFracParen(negPQ) + ' \\cdot ' + texFrac(rOverS) +
      ' + \\left(' + texDec(dec) + '\\right) \\cdot ' + texFracParen(tOverU);

    return { latex, frac: res };
  }
}

/* TYPE 4: (dec ‚àí 1/k) : ( f1 : f2 ) */
function genType4(){
  while(true){
    const dec = randDecFrac(1.5,2.5,[10]);
    const k = choice([4,5,8,10]);
    const oneOverK = makeFrac(1,k);

    const f1 = randNiceFrac(4,[2,4,5,10]);
    const f2 = randNiceFrac(4,[2,4,5,10]);

    const top = subFrac(dec, oneOverK);
    const inner = divFrac(f1, f2);
    const res = divFrac(top, inner);

    if(!isNiceResult(res)) continue;

    const latex =
      '\\left(' + texDec(dec) + ' - ' + texFrac(oneOverK) + '\\right) : ' +
      '\\left( ' + texFrac(f1) + ' : ' + texFrac(f2) + ' \\right)';

    return { latex, frac: res };
  }
}

/* TYPE 5: (‚àídec) ¬∑ a/b + (‚àíp/q) ¬∑ c/d */
function genType5(){
  while(true){
    const decPos = randDecFrac(0.4,0.9,[10]);
    const dec = makeFrac(-decPos.n, decPos.d);

    const frac1 = randNiceFrac(4,[9,3,6,2,4,5]);
    const frac2 = randNiceFrac(8,[6,9,12,4,8]);
    const mult  = randNiceFrac(6,[4,6,8,12]);

    const part1 = mulFrac(dec, frac1);
    const negFrac2 = makeFrac(-frac2.n, frac2.d);
    const part2 = mulFrac(negFrac2, mult);
    const res = addFrac(part1, part2);

    if(!isNiceResult(res)) continue;

    const latex =
      '\\left(' + texDec(dec) + '\\right) \\cdot ' + texFrac(frac1) +
      ' + ' + texFracParen(negFrac2) + ' \\cdot ' + texFrac(mult);

    return { latex, frac: res };
  }
}

/* TYPE 6: (fA ‚àí dec) : ( fB : fC ) */
function genType6(){
  while(true){
    const fA = randNiceFrac(4,[4,5,8,10]);
    const dec = randDecFrac(1.0,1.9,[10]);
    const fB = randNiceFrac(4,[2,3,4,6]);
    const fC = randNiceFrac(4,[3,4,5,6]);

    const top = subFrac(fA, dec);
    const inner = divFrac(fB, fC);
    const res = divFrac(top, inner);

    if(!isNiceResult(res)) continue;

    const latex =
      '\\left(' + texFrac(fA) + ' - ' + texDec(dec) + '\\right) : ' +
      '\\left( ' + texFrac(fB) + ' : ' + texFrac(fC) + ' \\right)';

    return { latex, frac: res };
  }
}

/* 6 p≈ô√≠klad≈Ø ‚Äì ka≈æd√Ω typ jednou */
function generateQuestions(){
  const gens = [genType1, genType2, genType3, genType4, genType5, genType6];
  return gens.map(g => {
    const q = g();
    const fr = q.frac;
    return {
      latex: q.latex + ' =',
      frac: fr,
      value: fracValue(fr),
      dec: fmtDec(fracValue(fr))
    };
  });
}

/* ---------- stav ---------- */
let roundNo = 1;
let questions = generateQuestions();
let index = 0;
let correctCount = 0;
let wrongCount = 0;
let grannyCount = 0;
let devilCount = 0;
let streakConsec = 0;
let roundFinished = false;

const elRoundNo = document.getElementById('roundNo');
const elQText  = document.getElementById('qText');
const elQIndex = document.getElementById('qIndex');
const elQCorrect = document.getElementById('qCorrect');
const elQWrong   = document.getElementById('qWrong');
const elStatus   = document.getElementById('status');

const elWhole = document.getElementById('answerWhole');
const elFracWrap = document.getElementById('fracWrapper');
const elNum = document.getElementById('answerNum');
const elDen = document.getElementById('answerDen');

const elBtnCheck = document.getElementById('btnCheck');
const elBtnNext = document.getElementById('btnNext');
const elBtnNextRound = document.getElementById('btnNextRound');
const elBtnResetAll = document.getElementById('btnResetAll');
const elKbd = document.getElementById('kbd');

const elGrannyCount = document.getElementById('grannyCount');
const elDevilCount  = document.getElementById('devilCount');

let fractionMode = false;
let activeInput = elWhole;

/* ---------- UI / MathJax ---------- */
function typeset(el){
  if(window.MathJax && MathJax.typesetPromise){
    MathJax.typesetPromise([el]).catch(()=>{});
  }
}

function setStatus(msg, kind, isTeX){
  elStatus.className = "status";
  if(kind === "ok") elStatus.classList.add("ok");
  if(kind === "bad") elStatus.classList.add("bad");
  elStatus.innerHTML = isTeX ? msg : msg.replace(/</g,"&lt;");
  typeset(elStatus);
}

function clearAnswer(){
  elWhole.value = "";
  elNum.value = "";
  elDen.value = "";
  fractionMode = false;
  elWhole.style.display = "inline-block";
  elFracWrap.style.display = "none";
  activeInput = elWhole;
  elBtnNext.disabled = true;
  elBtnCheck.disabled = false;
  elWhole.focus();
}

function showQuestion(){
  const q = questions[index];
  elQIndex.textContent = String(index+1);
  elQText.innerHTML = '\\(' + q.latex + '\\)';
  typeset(elQText);
  clearAnswer();
  setStatus("", null, false);
  roundFinished = false;
}

/* ---------- ƒçten√≠ odpovƒõdi ---------- */
function parseNumber(str){
  const s = str.replace(',', '.').trim();
  if(!s) return null;
  const n = Number(s);
  return Number.isFinite(n) ? n : null;
}
function getUserValue(){
  if(fractionMode){
    const a = parseNumber(elNum.value);
    const b = parseNumber(elDen.value);
    if(a === null || b === null || b === 0) return {ok:false, msg:"Dopl≈à ƒçitatel i jmenovatel (jmenovatel nesm√≠ b√Ωt 0)."};
    return {ok:true, value:a / b};
  }else{
    const a = parseNumber(elWhole.value);
    if(a === null) return {ok:false, msg:"Zadej v√Ωsledek (desetinn√° ƒç√°rka je , )."};
    return {ok:true, value:a};
  }
}

/* ---------- kontrola ---------- */
function addGrannyIfNeeded(){
  if(streakConsec > 0 && streakConsec % 6 === 0){
    grannyCount++;
    elGrannyCount.textContent = String(grannyCount);
  }
}

function checkAnswer(){
  const res = getUserValue();
  if(!res.ok){
    setStatus(res.msg, "bad", false);
    return;
  }
  const user = res.value;
  const correct = questions[index].value;
  const diff = Math.abs(user - correct);

  if(diff < 1e-6){
    correctCount++;
    elQCorrect.textContent = String(correctCount);
    streakConsec++;
    addGrannyIfNeeded();
    setStatus("Spr√°vnƒõ üëå", "ok", false);
  }else{
    wrongCount++;
    devilCount++;
    elQWrong.textContent = String(wrongCount);
    elDevilCount.textContent = String(devilCount);
    streakConsec = 0;

    const fr = questions[index].frac;
    const tex = '≈†patnƒõ. Spr√°vn√Ω v√Ωsledek je \\( ' +
      fmtDec(correct) + ' = ' + texFrac(fr) + ' \\).';
    setStatus(tex, "bad", true);
  }

  elBtnCheck.disabled = true;

  if(index >= questions.length-1){
    elBtnNext.disabled = true;
    elBtnNextRound.disabled = false;
    roundFinished = true;
  }else{
    elBtnNext.disabled = false;
  }
}

/* ---------- dal≈°√≠ / kola / reset ---------- */
function nextQuestion(){
  if(index < questions.length-1){
    index++;
    showQuestion();
  }
  if(index >= questions.length-1){
    elBtnNext.disabled = true;
  }
}

function startNextRound(){
  if(!roundFinished) return;
  roundNo++;
  elRoundNo.textContent = String(roundNo);
  questions = generateQuestions();
  index = 0;
  elBtnNextRound.disabled = true;
  showQuestion();
}

function resetAll(){
  roundNo = 1;
  questions = generateQuestions();
  index = 0;
  correctCount = 0;
  wrongCount  = 0;
  grannyCount = 0;
  devilCount  = 0;
  streakConsec = 0;
  elRoundNo.textContent = "1";
  elQCorrect.textContent = "0";
  elQWrong.textContent   = "0";
  elGrannyCount.textContent = "0";
  elDevilCount.textContent  = "0";
  elBtnNextRound.disabled = true;
  showQuestion();
}

/* ---------- kl√°vesnice ---------- */
function setActive(input){ activeInput = input; }
elWhole.addEventListener('focus', ()=>setActive(elWhole));
elNum.addEventListener('focus', ()=>setActive(elNum));
elDen.addEventListener('focus', ()=>setActive(elDen));

function handleKey(key){
  if(key === "frac"){
    if(!fractionMode){
      fractionMode = true;
      elWhole.style.display = "none";
      elFracWrap.style.display = "inline-flex";
      if(elWhole.value.trim()){
        elNum.value = elWhole.value;
      }
      activeInput = elNum.value.trim() ? elDen : elNum;
    }else{
      activeInput = (activeInput === elNum ? elDen : elNum);
    }
    activeInput.focus();
    return;
  }
  if(key === "clear"){
    activeInput.value = "";
    activeInput.focus();
    return;
  }
  if(key === "back"){
    activeInput.value = activeInput.value.slice(0,-1);
    activeInput.focus();
    return;
  }

  let v = activeInput.value;
  if(key === "neg"){
    if(v.startsWith("-")) return;
    activeInput.value = v ? "-" + v : "-";
    activeInput.focus();
    return;
  }
  if(key === ","){
    if(v.includes(",") || v.includes(".")) return;
    if(!v) v = "0";
    activeInput.value = v + ",";
    activeInput.focus();
    return;
  }
  if(/[0-9]/.test(key)){
    activeInput.value += key;
    activeInput.focus();
    return;
  }
}

elKbd.addEventListener('click', e=>{
  const btn = e.target.closest('button[data-key]');
  if(!btn) return;
  const key = btn.getAttribute('data-key');
  handleKey(key);
});

/* Enter = ovƒõ≈ôit */
document.addEventListener('keydown', e=>{
  if(e.key === "Enter"){
    e.preventDefault();
    if(!elBtnCheck.disabled) checkAnswer();
  }
});

/* ---------- tlaƒç√≠tka ---------- */
elBtnCheck.addEventListener('click', checkAnswer);
elBtnNext.addEventListener('click', nextQuestion);
elBtnNextRound.addEventListener('click', startNextRound);
elBtnResetAll.addEventListener('click', resetAll);

/* start */
showQuestion();
</script>
</body>
</html>
